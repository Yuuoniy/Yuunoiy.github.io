---
title: 课程 | 编译原理基础
date: 2018-09-18 10:33:08
tags:
---
### 第二章 正规式
#### 语法分析树
一颗语法分析树的叶子节点从左向右构成了树的结果。

#### 文法及其分类
文法：
文法 `G=（Vn，Vt，P，S）`，其中，Vn 代表非终结符的集合，Vt 代表终结符的集合，P 代表推导式的集合，S 代表开始符。

1. 0 型文法 短语文法 又称为无限制文法。这种文法对生成式 a→β不作特殊限制，a 和β可以是任意的文法符号串，当然 a 不能是空字符串。0 型文法是形式语言谱系中最大的文法类。由 0 型文法产生的形式语言恰是图灵机所识别的语言类，即递归可枚举语言。
2. 1 型文法 **线性有界自动机**  又称为上下文有关文法。这种文法要求生成式 a→β满足 **|a|≤|β|**，即β要至少和 a 一样长。由 1 型文法产生的语言称为 1 型语言或上下文有关语言。1 型语言恰是非确定型线性有界自动机所识别的语言类。
3. 2 型文法 **上下文无关文法** 这种文法要求生成式 a→β中的 a 必须是变元。由 2 型文法产生的语言称为 2 型语言或上下文无关语言。2 型语言恰是由**下推自动机**所识别的语言类。 上下文无关文法取名为“上下文无关”的原因就是因为字符 V 总可以被字串 w 自由替换，而无需考虑字符 V 出现的上下文。

4. 3 型文法 这种文法分为两种类型：第一类要求生成式的形式必须是 A→ωB 或 A→ω，其中 A，B 都是变元，ω是终结符串（可以是空串），这种特殊的正则文法称为右线性文法。第二类正则文法称为左线性文法，它要求生成式必须是 A→Bω，或 A→ω的形式。由正则文法生成的语言称为正则语言，它恰是有穷自动机所识别的语言类。

0 型文法对应图灵机。  1 型文法对应线性界限自动机。 2 型文法对应下推自动机。  3 型文法对应有限自动机。

##### 上下文无关文法与正则文法的区别
正则定义与上下文无关文法的重要区别在于，在正则定义中是不允许递归定义的，例如 A → aA|b 不是一个正则定义，为其左边的 A 必须是一个新的符号，也就是说不能在其他地方定义过，但是其右边要求每一个符号都是定义过的，因此这个定义无法满足。而上下文无关文法则没有这个约束，因此 A → aA|b 是一个上下文无关文法的产生式，但不是正则定义的定义式。

最左推导：每一步替换最左边的终结符
最右推导：每一步替换最右边的终结符。称为规范推导

小点：
1. 程序语言下面的单词符号中，标识符一般不需要超前搜索。
2. 从接受语言的能力上来说，非确定型有穷自动机和ⅰ. 左线性正规文法；ⅱ. 右线性正规文法；ⅲ. 确定性有穷自动机；
是等价的。
3. 词法分析的理论基础是有穷自动机理论
4. 词法分析器的输出结果是单词的种别编码和自身值
5. 无符号常数的识别和拼数工作通常都在词法分析阶段完成
6. 有穷自动机接受的语言是正则语言。

### 第三章 有穷自动机
#### 不确定的有穷自动机 NFA 
定义：一个不确定有穷自动机 NFA M 是一个五元组
M=(S,Σ,δ, s0 , F)
其中：
S: 状态集（非空，有穷）
Σ: 输入字母表（非空，有穷）
s0: 初始状态，s0∈S
F: 终止状态集，F S
状态转换函数 (transition function): δ: S×(Σ∪{ε})→2S
δ(s,a)={t1,t2,…,tk }. 

L(A) 表示自动机 A 接受的语言。如果两个文法生成的语言相同，那么我们认为这两个文法是等价的。这里道理是一样的，如果两个自动机识别的语言相同，那么我们也认为它们是等价的。

NFA 即假如一个输入符号，可以得到两个或者两个以上可能的状态，也就是说得到的可能的状态是不确定；DFA 即假如一个输入符号，只能得到唯一的一个可能的状态。
NFA 可以转换成 DFA，

#### 确定的有穷自动机
DFA=（Q ,Σ , t, q0, F）
Q：非空有穷状态集；
Σ：有穷输入字母表；
t：是一个单值映射 t(q,a) -> q’
q0：开始状态， q0∈Q
F：非空终止状态集

有穷自动机是不确定有穷自动机的一个特例，其中：
1. 没有输入 空串之上的转化动作
2. 对每个状态 s 和每个输入符号 a，有且只有一个标号为 a 的边离开

NFA 抽象地表示了用来室别某个语言中的串的算法，而相应的 DFA 则是一个简单具体的识别串的算法。
每个正则表达式和每个 DFA 都可以被转变成为一个接受相同语言的 DFA

#### 扩充映射
原来的映射 t：Q × ∑ → Q            扩展之后的映射 t：Q × ∑* → Q
DFA 扩展之后的映射定义为：
t（q，ε） = q
t（q，aα） = t（t（q，a），α）  其中，q ∈ Q，a ∈ ∑，α ∈ ∑*。

NFA 扩展之后的映射定义为：
t（q，ε） = { q }
t（q，aα） = t（q1，α） ∪ t（q2，α） ∪ ... ∪ t（qn，α） 其中，a ∈ ∑，α ∈ ∑*，t（q，a） = { q1，q2，q3， ... qn }。

#### NDFA 到 DFA 的转换
##### 等价性
NFA 与 DFA 识别语言的能力是一样的。DFA 是一个特殊的 NFA; 对任一 NFA, 可以构造一个与之等价的（识别同一语言的）DFA.
##### 基本思想
 NFA 读入一个串后，进入一个状态子集。从 NFA 变换到 DFA 的一般思想是：让 DFA 的每个状态代表 NFA 的一个状态子集，这个 DFA 用它的状态去保持 NFA 在读输入符号后能到达的所有状态的踪迹。

子集构造法
消除空移、造表法

#### 从正规文法到 FA
thompson 算法
####  DFA 的化简
串 x 区分 s 和 t: 分别从状态 s 和 t 出发，沿着标号为 x 的路径到达的两个状态中只有一个是接受状态。

死状态：在所有输入符号上都转向自己的非接受状态。

算法：极小化 DFA 的状态数
http://www.voidcn.com/article/p-qfotcrnh-boy.html

## 语法分析
自底向上的分析技术 有：
- 简单优先分析法
- 算符优先分析法
- 优先函数
- LR 分析法

自顶向下的分析技术 有：
- LL（1）分析法
- 递归下降分析法

###  自上而下的语法分析
#### 非确定的下推自动机 

#### LL(1) 文法
产生式 A—>α|β 满足下列条件：
（1）如果α、β均不能推导出ε，则 FIRST(α) ∩ FIRST(β) = ∅。 (不符合这个条件就不是LL(1)文法了)
（2）α 和 β 至多有一个能推导出 ε。
（3）如果 β *═> ε，则 FIRST(α) ∩ FOLLOW(A) = ∅。
将满足上述条件的文法称为**LL(1)文法**。

**FIRST 集**
由非终结符号推出的所有的开头符号或ε
规则：终结符的 FIRST 集，即是他本身
**FOLLOW**集：紧跟随其后面的终结符号或＃

**构造预测分析表**
方法：对于文法G的每个产生式 A-> $\alpha$
1. 对于 FIRST($\alpha$) 中的每个终结符号 a,将 A-> $\alpha$ 加入到M[A,a] 中。
2. 如果 空符号 在 FISRT($\alpha$) 中，那么吧  A-> $\alpha$ 加入都所有在 FOLLOW(A)  的终结符号
 
如果分析表中有多重定义的条目，则说明该文法不符合 LL(1) 文法
#### 递归向下分析法

### 自底向上的语法分析

一个句型中的最左简单短语称为该句型的句柄

一个句型的语法树中任一子树叶节点所组成的符号串都是该句型的**短语**。
当子树不包含其他更小的子树时，该子树叶节点所组成的字符串就是该句型的**直接短语**
**句柄**是最左边的**直接短语**
**素短语**是一个短语，它至少含有一个**终结符**，而且除他之外不含有其他素短语。
**最左素短语**是句型中最左边的素短语。
**句型**是推导过程中生成的产生式
**句型的句柄**是该句型中和一个产生式右部匹配的子串并把它规约成该产生式左部的非终结符，代表了最右推导过程中的逆过程的一步

一般的自底向上分析法，也称为**移进—归约**法，其一般过程为：

(1) 设置一个存放符号的栈称为符号栈，用于记录分析的过程和确定下一步的动作。

(2) 把输入符号按扫描顺序逐个移进栈里（符号栈），当栈顶的符号组成的符号串形成一个可归约串时，也就是形成某个句型的句柄时，（正好是某条产生式的右部），就进行归约。即把该符号串用与它对应的产生式左部的非终结符号代替，仍然置于栈顶。

(3) 接着检查新栈顶，若形成新的可归约串，再进行归约，若没有形成新可归约串，则从符号串中移进新的符号。如此重复，直到整个输入符号串处理完毕为止。

(4) 若最终栈底为识别符号，则表明所分析的输入串合法，报告分析成功；否则是不合法的符号串，报告出错信息。

移进-规约是规范推导（最右推导）的逆过程，即规范规约，是用句柄来刻画约束的

#### 简单优先分析法
- PDA 读入一个单词后，比较栈顶符号和该单词的优先级。若栈顶符号优先级低于该单词，继续入栈；
- 等于或高于时，寻找句柄进行规约，找不到就继续读入单词；
- 直至最终栈内只剩下开始符号，输入带剩下#，此时识别正确。

#### 算符优先分析法
算符文法的定义：

所有产生式的右部都不是ε或两个相邻的非终结符
设有一个文法 G，如果 G 中没有形如 A→…BC…的产生式，其中 B 和 C 为非终结符，则称 G 为算符文法`(Operator Grammar)`也称 OG 文法。

**算符优先分析**的基本思想是只规定算符（广义为终结符）之间的优先关系，也就是只考虑终结符之间的优先关系，不考虑非终结符之间的优先关系，在在归约过程中只要找到可规约串就规约，并不考虑归约到那个非终结符名。算符优先分析的可规约串不一定是规范句型的句柄，所以算符优先归约不是规范归约。算符优先分析的可规约串是当前符号栈中的符号和剩余的输入符号构成句型的**最左素短语**。

最右推导所产生的句型称为**右句型**。
**计算句型的句柄**: 应用算符优先分析法
句柄的确定只和每一层最左边的推导有关系；和右边的推导无关

#### 优先函数及其构造
不考。.
- 简单优先矩阵
- 算法优先矩阵

#### LR 技术

规范 LR(0) 项集族的构造
构造过程中用到的子函数
- `CLOSURE(I)`：I 的项集闭包
  对应于 DFA 化算法的` ε-CLOSURE`
- `GOTO(I,X)`：I 的 X 后继
  对应于 DFA 化算法的`MOVE(I,X)`。

**内核项**：初始项 S’->.S、以及所有点不在最左边的项
**非内核项**：除了 S’->.S 之外、点在最左边的项；

LR(0) 自动机的构造

LR 语法分析表的结构
- 动作 ACTION
- 转换 GOTO
首先构造 Fllow 
依次查看每个项目集，对于每个终结符和非终结符的状态，看应该是归约 移进，或者转移到另外的项目集
如果。在产生式右部的右端，则进行归约，对于产生式左边的符号的每个 FOLLOW 号进行归约，选择归约的产生式

非 SLR 文法：
存在非 SLR 的上下文无关文法


#### LL(1) 文法
先提取左公共因子，再消除左递归，这样就有可能变为LL(1)文法。然后要分别写出改写后文法的FIRST集、FOLLOW集、SELECT集，如果相同左部的SELECT集的交集为空集，则为LL(1)文法


#### LALR

### 语法制导翻译

三元式：按照归约顺序产生的代码
间接三元式：

### 语法分析方法
不确定型
- 推导
- 语法树
确定型
- LL分析
- 优先法
- LR 分析法

逐步求精方法
